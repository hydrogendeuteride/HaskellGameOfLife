type Pos = (Int, Int)
type Board = [(Pos, Int)]

row = 30
col = 50

--width :: [[a]] -> Int
--width = length

--height :: [[a]] -> Int
--height = length . (!! 0)

bData = "\
    \..................................................\
    \..................................................\
    \..................................................\
    \...............................X..................\
    \.............................X.X..................\
    \...................XX......XX............XX.......\
    \..................X...X....XX............XX.......\
    \.......XX........X.....X...XX.....................\
    \.......XX........X...X.XX....X.X..................\
    \.................X.....X.......X..................\
    \..................X...X...........................\
    \...................XX.............................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \..................................................\
    \.................................................."

firstBoard::Board
firstBoard = zip [(x, y) | x <- [1..row], y <- [1..col]] (map trans bData)
    where trans '.' = 0
          trans 'X' = 1
          trans  _  = 0

inBoard :: Board -> Int -> Int -> Bool
inBoard b x y = (x `elem` [0..row]) && ( y `elem` [0..col])

arounds::Board -> Int -> Int -> [Pos]
arounds b x y = filter (uncurry $ inBoard b) [(x + x', y + y') | x' <- [-1..1], y' <- [-1..1], x' /= 0 || x' -y' /= 0]

isAlive :: Board -> Pos -> Bool
isAlive b (x, y) = b !! ((row * x) + y) == ((x, y), 1)

liveNeighbs ::Board -> Pos -> Int
liveNeighbs b (x, y) = isAlive2 (arounds b x y) where
    isAlive2 [] = 0
    isAlive2 (x:xs) = if isAlive b x
                            then 1 + isAlive2 xs
                        else
                            0 + isAlive2 xs

gameOfLife :: Board -> Board
gameOfLife b = map nextGen b
    where nextGen ((x, y), cellState) = ((x, y), newState)
            where newState = if (cellState, liveNeighbs b (x,y)) `elem` alive 
                                then 1 
                             else 0
                  alive = [(0, 3), (1, 2), (1, 3)]